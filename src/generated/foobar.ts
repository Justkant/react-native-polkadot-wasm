// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './foobar-ffi';
import {
  type UniffiByteArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterUInt32,
  FfiConverterUInt8,
  RustBuffer,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Generate a bip39 phrase
 *
 * words: number of words, either 12, 15, 18 21 or 24
 *
 * Returns the bip 39 phrase
 */
export function extBip39Generate(words: /*u32*/ number): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_bip39_generate(
          FfiConverterUInt32.lower(words),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create entropy from a bip39 phrase
 *
 * * phrase: mnemonic phrase
 *
 * Returns the entropy
 */
export function extBip39ToEntropy(phrase: string): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_bip39_to_entropy(
          FfiConverterString.lower(phrase),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create a mini-secret from a bip39 phrase
 *
 * * phrase: mnemonic phrase
 *
 * Returns the 32-byte mini-secret via entropy
 */
export function extBip39ToMiniSecret(
  phrase: string,
  password: string
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_bip39_to_mini_secret(
          FfiConverterString.lower(phrase),
          FfiConverterString.lower(password),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Creates a BTC/ETH compatible seed from a bip-39 phrase
 *
 * @phrase: mnemonic phrase
 *
 * Returns a 32-byte seed
 */
export function extBip39ToSeed(phrase: string, password: string): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_bip39_to_seed(
          FfiConverterString.lower(phrase),
          FfiConverterString.lower(password),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Validates a bip39 phrase
 *
 * * phrase: mnemonic phrase
 *
 * Returns the true/false
 */
export function extBip39Validate(phrase: string): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_bip39_validate(
          FfiConverterString.lower(phrase),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * blake2b hash for the specified input
 *
 * * data: Arbitrary data to be hashed
 * * key: Key to add to the hashing (normally empty)
 * * size: Size in bytes of the resulting output
 *
 * Returns a vector with the hash result
 */
export function extBlake2b(
  data: ArrayBuffer,
  key: ArrayBuffer,
  size: /*u32*/ number
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_blake2b(
          FfiConverterArrayBuffer.lower(data),
          FfiConverterArrayBuffer.lower(key),
          FfiConverterUInt32.lower(size),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a key pair.
 *
 * * seed: UIntArray with 32 element
 *
 * returned vector is the concatenation of first the seed (32 bytes)
 * followed by the public key (32) bytes, as the full secret keys.
 */
export function extEdFromSeed(seed: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_ed_from_seed(
          FfiConverterArrayBuffer.lower(seed),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Sign a message
 *
 * The combination of both public and private key must be provided.
 * This is effectively equivalent to a keypair.
 *
 * * _pubkey: UIntArray with 32 element (was pubkey, now ignored)
 * * private: UIntArray with 64 element
 * * message: Arbitrary length UIntArray
 *
 * * returned vector is the signature consisting of 64 bytes.
 */
export function extEdSign(
  pubkey: ArrayBuffer,
  seckey: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_ed_sign(
          FfiConverterArrayBuffer.lower(pubkey),
          FfiConverterArrayBuffer.lower(seckey),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Verify a message and its corresponding against a public key;
 *
 * * signature: UIntArray with 64 element
 * * message: Arbitrary length UIntArray
 * * pubkey: UIntArray with 32 element
 */
export function extEdVerify(
  signature: ArrayBuffer,
  message: ArrayBuffer,
  pubkey: ArrayBuffer
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_ed_verify(
          FfiConverterArrayBuffer.lower(signature),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterArrayBuffer.lower(pubkey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * hmac with sha256
 */
export function extHmacSha256(
  key: ArrayBuffer,
  data: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_hmac_sha256(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * hmac with sha512
 */
export function extHmacSha512(
  key: ArrayBuffer,
  data: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_hmac_sha512(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create a keccak256 hash for the specified input
 *
 *
 * Returns the hash as a vector
 */
export function extKeccak256(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_keccak256(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Create a keccak512 hash for the specified input
 *
 *
 * Returns the hash as a vector
 */
export function extKeccak512(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_keccak512(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * pbkdf2 kdf from an input, salt for the number of specified rounds
 *
 * * data: Arbitrary data to be hashed
 * * salt: Salt for this hash
 * * rounds: The number of rounds to perform
 *
 * Returns a vector with the hashed result
 */
export function extPbkdf2(
  data: ArrayBuffer,
  salt: ArrayBuffer,
  rounds: /*u32*/ number
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_pbkdf2(
          FfiConverterArrayBuffer.lower(data),
          FfiConverterArrayBuffer.lower(salt),
          FfiConverterUInt32.lower(rounds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * scrypt kdf from input, salt and config
 *
 * * password: Password to hash
 * * salt: Salt for this hash
 * * log2_n: log2(n)
 * * r: r
 * * p: p
 *
 * Returns vector with the hashed result
 */
export function extScrypt(
  password: ArrayBuffer,
  salt: ArrayBuffer,
  log2N: /*u8*/ number,
  r: /*u32*/ number,
  p: /*u32*/ number
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_scrypt(
          FfiConverterArrayBuffer.lower(password),
          FfiConverterArrayBuffer.lower(salt),
          FfiConverterUInt8.lower(log2N),
          FfiConverterUInt32.lower(r),
          FfiConverterUInt32.lower(p),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * sha256 hash for the specified input
 *
 * * data: Arbitrary data to be hashed
 *
 * Returns a vector with the hash result
 */
export function extSha256(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sha256(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * sha512 hash for the specified input
 *
 * * data: Arbitrary data to be hashed
 *
 * Returns a vector with the hash result
 */
export function extSha512(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sha512(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Key agreement between other's public key and self secret key.
 *
 * * pubkey: UIntArray with 32 element
 * * secret: UIntArray with 64 element
 *
 * * returned vector is the generated secret of 32 bytes.
 */
export function extSrAgree(
  pubkey: ArrayBuffer,
  secret: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_agree(
          FfiConverterArrayBuffer.lower(pubkey),
          FfiConverterArrayBuffer.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Perform a derivation on a secret
 *
 * * secret: UIntArray with 64 bytes
 * * cc: UIntArray with 32 bytes
 *
 * returned vector the derived keypair as a array of 96 bytes
 */
export function extSrDeriveKeypairHard(
  pair: ArrayBuffer,
  cc: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_derive_keypair_hard(
          FfiConverterArrayBuffer.lower(pair),
          FfiConverterArrayBuffer.lower(cc),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Perform a derivation on a secret
 *
 * * secret: UIntArray with 64 bytes
 * * cc: UIntArray with 32 bytes
 *
 * returned vector the derived keypair as a array of 96 bytes
 */
export function extSrDeriveKeypairSoft(
  pair: ArrayBuffer,
  cc: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_derive_keypair_soft(
          FfiConverterArrayBuffer.lower(pair),
          FfiConverterArrayBuffer.lower(cc),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Perform a derivation on a publicKey
 *
 * * pubkey: UIntArray with 32 bytes
 * * cc: UIntArray with 32 bytes
 *
 * returned vector is the derived publicKey as a array of 32 bytes
 */
export function extSrDerivePublicSoft(
  pubkey: ArrayBuffer,
  cc: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_derive_public_soft(
          FfiConverterArrayBuffer.lower(pubkey),
          FfiConverterArrayBuffer.lower(cc),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a key pair.
 *
 * * seed: UIntArray with 32 element
 *
 * returned vector is the concatenation of first the private key (64 bytes)
 * followed by the public key (32) bytes.
 */
export function extSrFromSeed(seed: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_from_seed(
          FfiConverterArrayBuffer.lower(seed),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Sign a message
 *
 * The combination of both public and private key must be provided.
 * This is effectively equivalent to a keypair.
 *
 * * pubkey: UIntArray with 32 element
 * * private: UIntArray with 64 element
 * * message: Arbitrary length UIntArray
 *
 * * returned vector is the signature consisting of 64 bytes.
 */
export function extSrSign(
  pubkey: ArrayBuffer,
  secret: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_sign(
          FfiConverterArrayBuffer.lower(pubkey),
          FfiConverterArrayBuffer.lower(secret),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Verify a message and its corresponding against a public key;
 *
 * * signature: UIntArray with 64 element
 * * message: Arbitrary length UIntArray
 * * pubkey: UIntArray with 32 element
 */
export function extSrVerify(
  signature: ArrayBuffer,
  message: ArrayBuffer,
  pubkey: ArrayBuffer
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_sr_verify(
          FfiConverterArrayBuffer.lower(signature),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterArrayBuffer.lower(pubkey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * twox hash for the specified input and rounds
 *
 * * data: Arbitrary data to be hashed
 * * rounds: Number of 8-byte rounds to add to the output
 *
 * Returns a vector with the hash result
 */
export function extTwox(
  data: ArrayBuffer,
  rounds: /*u32*/ number
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_twox(
          FfiConverterArrayBuffer.lower(data),
          FfiConverterUInt32.lower(rounds),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Run a Random Verifiable Function (VRF) on one single input
 * (message) transcript, and an extra message transcript,
 * producing the output signature and corresponding short proof.
 *
 * * secret: UIntArray with 64 element
 * * context: Arbitrary length UIntArray
 * * message: Arbitrary length UIntArray
 * * extra: Arbitrary length UIntArray
 *
 * * returned vector is the 32-byte output (signature) and 64-byte proof.
 */
export function extVrfSign(
  secret: ArrayBuffer,
  ctx: ArrayBuffer,
  msg: ArrayBuffer,
  extra: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_vrf_sign(
          FfiConverterArrayBuffer.lower(secret),
          FfiConverterArrayBuffer.lower(ctx),
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(extra),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Verify VRF proof for one single input transcript, and an extra message transcript,
 * and corresponding output.
 *
 * * pubkey: UIntArray with 32 element
 * * context: Arbitrary length UIntArray
 * * message: Arbitrary length UIntArray
 * * extra: Arbitrary length UIntArray
 * * out_and_proof: 96-byte output & proof array from the ext_sign function.
 */
export function extVrfVerify(
  pubkey: ArrayBuffer,
  ctx: ArrayBuffer,
  msg: ArrayBuffer,
  extra: ArrayBuffer,
  out: ArrayBuffer
): boolean {
  return FfiConverterBool.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_foobar_fn_func_ext_vrf_verify(
          FfiConverterArrayBuffer.lower(pubkey),
          FfiConverterArrayBuffer.lower(ctx),
          FfiConverterArrayBuffer.lower(msg),
          FfiConverterArrayBuffer.lower(extra),
          FfiConverterArrayBuffer.lower(out),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_foobar_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_bip39_generate() !==
    34114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_bip39_generate'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_bip39_to_entropy() !==
    48085
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_bip39_to_entropy'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_bip39_to_mini_secret() !==
    9361
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_bip39_to_mini_secret'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_bip39_to_seed() !==
    44172
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_bip39_to_seed'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_bip39_validate() !==
    52972
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_bip39_validate'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_blake2b() !== 27771) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_blake2b'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_ed_from_seed() !== 28239
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_ed_from_seed'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_ed_sign() !== 33858) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_ed_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_ed_verify() !== 64518
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_ed_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_hmac_sha256() !== 3590
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_hmac_sha256'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_hmac_sha512() !== 27955
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_hmac_sha512'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_keccak256() !== 30545
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_keccak256'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_keccak512() !== 50806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_keccak512'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_pbkdf2() !== 41703) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_pbkdf2'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_scrypt() !== 17405) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_scrypt'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sha256() !== 45395) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sha256'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sha512() !== 62746) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sha512'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_agree() !== 4194) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_agree'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_derive_keypair_hard() !==
    12490
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_derive_keypair_hard'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_derive_keypair_soft() !==
    22529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_derive_keypair_soft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_derive_public_soft() !==
    47415
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_derive_public_soft'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_from_seed() !== 29923
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_from_seed'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_sign() !== 60023) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_sr_verify() !== 49203
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_sr_verify'
    );
  }
  if (nativeModule().ubrn_uniffi_foobar_checksum_func_ext_twox() !== 8652) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_twox'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_vrf_sign() !== 44155
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_vrf_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_foobar_checksum_func_ext_vrf_verify() !== 42984
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_foobar_checksum_func_ext_vrf_verify'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
});
